-- Step 1: Create the missing 'logs' table if it doesn't exist
CREATE TABLE IF NOT EXISTS public.logs (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    level text,
    message text,
    context jsonb
);
COMMENT ON TABLE public.logs IS 'Table for application-level logging.';

-- Step 2: Fix the user profile creation trigger with CASCADE
-- The previous script failed because other objects depended on the handle_new_user function.
-- Using CASCADE will automatically drop those dependent objects (like the old trigger)
-- before dropping the function. We will then recreate everything correctly.

-- Drop the function and any dependent triggers (like on_auth_user_created)
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;

-- Now, create the corrected function
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  -- Insert a new profile row for the new user.
  -- It pulls the full_name from the metadata provided during sign-up.
  -- It sets the default role to 'client'.
  INSERT INTO public.profiles (id, full_name, email, role)
  VALUES (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.email,
    'client' -- All new users start as 'client' by default
  );
  RETURN new;
END;
$$;

-- Create the trigger that executes the function after a new user is created in auth.users
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Log the successful fix
INSERT INTO public.logs (level, message, context)
VALUES ('info', 'Fixed schema with CASCADE: updated handle_new_user trigger.', '{"script": "020-fix-trigger-dependency.sql"}');
